package com.example.coreprinciple;

public class CompareCPlusPlus {

    // c++ 에서는 복사 생성자라는 개념을 도입하고 있다.
    // 선언과 동시에 초기화한 경우에는 일반적인 생성자가 아닌 복사 생성자가 호출 되는 것이다.

    // 애초에 선언과 동시에 대입하는 일은 없으며, 나는 항상 2행으로 나눠 쓴다.
    // 효율이 떨어질지도 모르지만, 기계가 개선되면 해결될 문제이므로 복사 생성자 따위는 의식하지 않아도 된다?

    // 기본적으로 복사 생성자는 shallow copy 를 하므로 객체가 포인터를 포함하는 경우 문제가 발생할 수 있다.
    // 그냥 대입하거나 선언과 동시에 대입하거나 파라미터를 건네줄 뿐인데 c++ 에서는 배후에서 이처럼 복잡한 처리가 행해지고 있는 것이다.

    // 덕분에 c++ 은 지나치게 복잡하고 습득하기 어려운 언어가 되고 말았다.

    // Java에는 포인터밖에 없으므로 경우 따라서는 clone() 메소드를 작성하는 등의 배려를 해야 하는 경우도 있지만.
    // 언어 자체는 c++ 만큼 복잡하지 않다.

    // 상속의 문제

    // 상속에 관해서는 3장에서 설명하고 있다.
    // 아직 상속의 개념을 잘 이해하지 못하는 사람은 먼저 3장을 훑어보고 나서 이 부분을 읽기 바란다.

    // 흔히 상속은 is a 관계라고 한다. Student is a person 이라고 할 수 있는 것이다.

    // 이것은 말하자면 모든 Student 는 Person 으로 취급해야 한다는 것이다.

    // 이것은 말하자면 모든 Student는 Person 으로도 취급해야 한다는 것이다.

    // 그러면 Student 의 객체를 Person 으로 취급하기 위해 Person 형 변수에 Student의 객체를 대입할 수 있을까?
    // 대부분의 경우 서브 클래스는 슈퍼 클래스보다 필드가 증가해 있는 상태이므로 들어갈 리가 없다. 이 때 C++ 은 슬라이싱
    // 이라는 무서운 현상이 발생하여, 미처 들어가지 못한 정보는 그대로 버려지게 된다.

    // 2.5.4

    // 2.4.5 포인터만 있으면 된다.

    // 2.4.5 왜 변수의 포인터를 취할 수 없는가? 에서 설명했듯이 Java 에서는 변수의 포인터를 취할 수 없다.
    // 즉 C 에서의 & 연산자가 없는 것이다.
    // 만일 java 에서 객체의 실체를 직접 취급할 수 있게 된다면 일단 실체로 stack or static 에 확보한 객체에 관해서는
    // 더 이상 포인터를 취득할 수 없게 될 것이다.

    // 메소드의 파라미터 등에서 객체의 포인터가 요구되는 경우는 매우 많다. 어떤 객체에 대하여 무언가를 처리하고 싶을 때는
    // 반드시 포인터가 필요해진다. 메소드의 파라미터에 있어 포인터가 아닌 실체를 건네주면 그것은 더이상 원하는 객체가 아니라
    // 원하는 객체의 복사본이 된다.

    // Java 에서는 파라미터는 값 건네주기 call by value 이기 때문이다.

    // 어차피 포인터가 필요해질 것이므로 처음부터 전부 포인터로 해두면 문제가 발생하지 않을 것이다.

    // 그러나 전부 포인터이고 그 포인터들이 얽히고 설키면 동적 별명 등이 일어나 규명이 어려워진다고 하는 문제는 있다.

    // 그러한 문제와 문법의 간편화를 저울에 달아본 후 Java 는 프리미티브 이외는 모두 포인터 라는 선택을 한 것이다.


}
