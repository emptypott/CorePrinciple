package com.example.coreprinciple.nowinheritence;

public class InterfaceStudy {

    // 자바에는 클래스의 다중 상속이 없는 대신 인터페이스를 사용한다는 설명이

    // 자바의 인터페이스라는 개념을 더욱 이해하기 어렵게 만들고 있는 듯하다.

    // 여기서는 조금 다른 각도에서 인터페이스에 대하여 접근해 보도록 하겠다.

    // 3.4.1

    // 인터페이스는 다중 상속의 대용품인가?

    // Java의 입문서 등에는 다음과 같은 기술이 자주 등장한다.

    // Java에는 다중 상속은 없다. 다중 상속과 같은 역할을 수행하고 싶을 때는
    // 인터페이스를 사용한다.

    // 이런 설명을 접하면 인터페이스는 마치 다중 상속의 대용품인 것처럼 여겨진다.

    // 가령 C++에는 다중 상속이 있지만, Java에는 단일 상속밖에 없으므로

    // 다중 상속을 실현하고 싶으면 대신 인터페이스를 사용해야 한다, 즉

    // Java는 다중 상속이라는 중요한 기능을 갖추고 있지 않아 인터페이스라는 대용품으로 얼렁뚱땅 땜질을 하고 있는 엉성한 언어이다.

    // 라는 오해를 하게 되는 것이다.

    // .. 중략

    // 그러나 실제로 프로그램을 만들어 보면 이 책에서 지금까지 설명한 상속과 Java의 인터페이스라는 기능은 매우 다른것이라는
    // 사실을 알 수 있다.
    // 언어에 다중 상속 기능이 있으면 인터페이스는 불필요하지만, Java에서는 의미가 다른 것에는 다른 구문을 부여해야 한다는
    // 규칙에 따라 interface가 도입되었다고 일단 호의적으로 받아들이기로 하자.

    // 인터페이스는 인터페이스이다.

    // Window DrawLine(), DrawCircle() 메소드.

    // class 대신 interface 라고 되어 있는 것을 제외하고 보기에는 클래스의 선언과 매우 비슷하다.
    // 그런데 메소드의 내용이 없다.
    // 인터페이스는 어디까지나 인터페이스 일뿐 실제 구현부분은 수반하지 않는 것이다.

    // 이것은 abstract 메소드와 동일하다. 이처럼 구현 부분이 없는 메소드의 선언을 메소드 시그니처라고 한다.

    // "중요한 사항"

    // 인터페이는 결국 final 필드와 abstract 메소드 밖에 쓸 수 없는 클래스와 동일하지 않은가?

    // 맞는 말이다. 그러나, 상속과 인터페이스는 그 용도가 전혀 다르다.

    // Drawable은 무언가에 직선이나 원을 그리기 위한 인터페이스이다.
    // 아닌 C와 같은 언어로 개발을 하는 경우에도 우선 전체를 모듈로 분할하여 개발팀에 할당한 다음
    // 각 모듈의 인터페이스를 정한다.

    // 이 때 작성하는 것은 함수의 프로토타입 선언, 즉 구현부분이 없는 메소드의 선언으로, Java의 인터페이스에 쓰는 것과 동일하다.

    // 단, C의 프로젝트에서 인터페이스를 정할 때는 구현은 1종류만 생각하지만, Java의 경우는 Window Paper를

    // 실행시 전환할 수 있다는 점이 다르기는 하다.

    // 천천히 그리고 확실히
}
