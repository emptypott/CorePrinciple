package com.example.coreprinciple.packagestudy;

import java.util.List;

public class PackageStudy {

    // 이전에 배웠던 내용을 조금 복습할 겸 적어본다.

    // 패키지는 계층 구조인가.

    // 패키지의 이름을 계층적으로 명명할 수 있을 뿐 패키지 구조 자체에는 어떤 계층적인 의미 부여도
    // 할 수 없는 것이다.

    // UNIX, Windows, Macintosh 의 파일 시스템에 있어 디렉토리와 폴더는 계층 구조로 되어있다.
    // 그러나 Java의 패키지는 적어도 파일 시스템과 같은 구조를 취하고 있지는 않다.

    // Java 에서는 패키지의 이름을 계층적으로 명명할 수 있을 뿐 패키지 구조 자체는 평평하다.

    // 클래스의 Fully Qualified Class

    // 컴파일하여 바이트 코드가 된 시점에는 모두 완전 한정 이름으로 치환된다.

    // 명령 프롬프트로 한번 확인해보는 것도 좋을 것 같다.
    // 과제다. 있다가 작성해보자.

    // Java에서 진짜 클래스 이름은 패키지 이름을 포함한 완전 한정 이름이다.

    // import의 기능은 클래스 이름을 쓸 때 완전 한정 이름이 아닌 단순 이름을 쓸 수 있도록 하는 것이다.

    // 1. 완전 한정 이름을 직접 쓴다.
    // 2. 단일 형식 임포트 선언을 사용한다.
    // 3. 온디멘드 형식 임포트 선언을 사용한다.

    // import java.io.*; 라고 쓰면 java io 패키지의 모든 액세스 가능한 클래스
    // public 클래스? 가 필요에 따라 임포트 된다.
    //

    public void findListImport() {
        // android studio 에는 java.awt 는 없구나.
        // "*"는 클래스 이름의 대용품으로만 쓸 수 있다는 점에도 주의해야 한다.
        // java.* 라고 썼다고 해서 java 패키지 이하의 모든 클래스가 임포트 되는 것은 아니다.

        // 패키지 구조 자체가 평평하다는 사실을 정확하게 인지해야 한다.

        // 동일한 패키지에 존재하는 클래스라면 import 하지 않아도
        // 단순 이름으로 지정할 수 있다.
        // java.lang 패키지는 자동으로 import 되므로, 특별히 import 선언을 작성할 필요가 없다.

        // import 선언은 단순 이름으로 지정된 클래스에 대하여 클래스의 완전한정이름을 정하기 위한
        // 힌트를 컴파일러에 제공하고 있을 뿐이다.
        // 컴파일러는 단순 이름으로 지정된 클래스를 발견하면 다음과 같은 순서로 그 클래스를 검색한다.

        // 그 클래스 자신
        // 단일 형식 임포트 선언된 클래스
        // 동일한 패키지에 존재하는 다른 클래스
        // 온디멘드 형식 임포트 선언된 클래스

        // 정리. import는 클래스 이름을 쓸 때, 클래스의 완전 한정 이름 대신 단순한 이름을 쓸 수 있게 하는 기능만 갖고 있다.



    }
}
